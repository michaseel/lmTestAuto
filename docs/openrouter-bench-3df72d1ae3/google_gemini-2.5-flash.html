<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vibrant Kanban Board</title>
    <!-- Tailwind CSS CDN -->
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <!-- Google Fonts for a modern look -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for a modern and vibrant look */
        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(to right bottom, #6a11cb, #2575fc); /* Vibrant gradient background */
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            color: #e0e0e0;
        }
        .kanban-board {
            display: grid;
            grid-template-columns: repeat(4, minmax(280px, 1fr));
            gap: 1.5rem;
            padding: 2rem;
            flex-grow: 1;
            overflow-x: auto;
            align-items: flex-start; /* Align columns to the top */
        }
        .kanban-column {
            background-color: rgba(255, 255, 255, 0.1); /* Slightly transparent white */
            border-radius: 1rem;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease-in-out;
            min-width: 280px;
        }
        .kanban-column.drag-over {
            background-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-5px);
        }
        .kanban-column-header {
            font-size: 1.5rem;
            font-weight: 700;
            color: #ffffff;
            margin-bottom: 1rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .kanban-card {
            background-color: #ffffff;
            border-radius: 0.75rem;
            padding: 1rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            cursor: grab;
            transition: all 0.3s ease-in-out;
            color: #333;
            position: relative;
        }
        .kanban-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }
        .kanban-card.dragging {
            opacity: 0.6;
            transform: scale(0.98);
            cursor: grabbing;
        }
        .card-content {
            min-height: 40px;
            outline: none;
            word-wrap: break-word;
            white-space: pre-wrap;
            padding-right: 2rem; /* Space for delete button */
        }
        .card-content:focus {
            background-color: #f0f8ff;
            border-radius: 0.5rem;
        }
        .add-card-btn {
            background-color: #4CAF50; /* Green */
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: background-color 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }
        .add-card-btn:hover {
            background-color: #45a049;
            transform: translateY(-1px);
        }
        .delete-card-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: #ef4444; /* Red */
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease;
            opacity: 0.8;
        }
        .delete-card-btn:hover {
            background-color: #dc2626;
            opacity: 1;
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.3s ease;
        }
        .modal-overlay.show {
            visibility: visible;
            opacity: 1;
        }
        .modal-content {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
            text-align: center;
            color: #333;
            transform: translateY(-20px);
            transition: transform 0.3s ease;
        }
        .modal-overlay.show .modal-content {
            transform: translateY(0);
        }
        .modal-content h3 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: #333;
        }
        .modal-content p {
            margin-bottom: 1.5rem;
            color: #555;
        }
        .modal-actions button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .modal-actions .btn-confirm {
            background-color: #ef4444;
            color: white;
            margin-right: 1rem;
        }
        .modal-actions .btn-confirm:hover {
            background-color: #dc2626;
        }
        .modal-actions .btn-cancel {
            background-color: #e5e7eb;
            color: #4b5563;
        }
        .modal-actions .btn-cancel:hover {
            background-color: #d1d5db;
        }

        /* Confetti animation styles */
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background-color: currentColor; /* Inherit color from JS */
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            animation: fadeOut 0.8s forwards;
            z-index: 9999;
        }

        @keyframes fadeOut {
            0% {
                opacity: 1;
                transform: translate(0, 0) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: translate(var(--x), var(--y)) rotate(var(--r));
            }
        }
    </style>
</head>
<body class="antialiased">
    <header class="text-center py-8">
        <h1 class="text-5xl font-bold text-white tracking-wider">Kanban Board</h1>
    </header>

    <div class="kanban-board" id="kanbanBoard">
        <!-- Columns will be rendered here by JavaScript -->
    </div>

    <!-- Confirmation Modal Structure -->
    <div id="confirmationModal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="modalTitle"></h3>
            <p id="modalMessage"></p>
            <div class="modal-actions">
                <button id="confirmButton" class="btn-confirm">Confirm</button>
                <button id="cancelButton" class="btn-cancel">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Namespace for localStorage
        const KANBAN_NAMESPACE = 'kanban_board_data';

        // Column definitions
        const COLUMNS = [
            { id: 'backlog', title: 'Backlog' },
            { id: 'in-progress', title: 'In Progress' },
            { id: 'review', title: 'Review' },
            { id: 'done', title: 'Done' }
        ];

        // --- Utility Functions ---

        /**
         * Generates a unique ID for cards.
         * @returns {string} A unique ID.
         */
        function generateUniqueId() {
            return '_' + Math.random().toString(36).substr(2, 9);
        }

        /**
         * Saves the current state of the board to localStorage.
         * @param {object} boardData - The entire board's data (columns and cards).
         */
        function saveBoardState(boardData) {
            localStorage.setItem(KANBAN_NAMESPACE, JSON.stringify(boardData));
        }

        /**
         * Loads the board state from localStorage.
         * If no data exists, it initializes with dummy cards.
         * @returns {object} The board data.
         */
        function loadBoardState() {
            const storedData = localStorage.getItem(KANBAN_NAMESPACE);
            if (storedData) {
                return JSON.parse(storedData);
            } else {
                // Initialize with dummy cards if no data exists
                return {
                    'backlog': [
                        { id: generateUniqueId(), content: 'Setup project environment' },
                        { id: generateUniqueId(), content: 'Design user interface mockups' }
                    ],
                    'in-progress': [
                        { id: generateUniqueId(), content: 'Implement drag-and-drop functionality' }
                    ],
                    'review': [
                        { id: generateUniqueId(), content: 'Code review for persistence layer' }
                    ],
                    'done': [
                        { id: generateUniqueId(), content: 'Initial Kanban board setup' },
                        { id: generateUniqueId(), content: 'Basic styling with Tailwind CSS' }
                    ]
                };
            }
        }

        /**
         * Shows a custom confirmation modal.
         * @param {string} title - The title of the modal.
         * @param {string} message - The message to display.
         * @returns {Promise<boolean>} Resolves to true if confirmed, false if cancelled.
         */
        function showConfirmationModal(title, message) {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirmationModal');
                const modalTitle = document.getElementById('modalTitle');
                const modalMessage = document.getElementById('modalMessage');
                const confirmButton = document.getElementById('confirmButton');
                const cancelButton = document.getElementById('cancelButton');

                modalTitle.textContent = title;
                modalMessage.textContent = message;

                // Clear previous event listeners to prevent multiple triggers
                confirmButton.onclick = null;
                cancelButton.onclick = null;

                // Add event listeners
                confirmButton.onclick = () => {
                    modal.classList.remove('show');
                    resolve(true);
                };
                cancelButton.onclick = () => {
                    modal.classList.remove('show');
                    resolve(false);
                };

                // Show the modal
                modal.classList.add('show');
            });
        }


        // --- Confetti Animation ---

        /**
         * Triggers a confetti animation at a given position.
         * @param {number} x - X coordinate for the confetti origin.
         * @param {number} y - Y coordinate for the confetti origin.
         */
        function triggerConfetti(x, y) {
            const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4CAF50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'];
            for (let i = 0; i < 50; i++) { // Generate 50 confetti pieces
                const confetti = document.createElement('div');
                confetti.classList.add('confetti');
                confetti.style.left = `${x}px`;
                confetti.style.top = `${y}px`;
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];

                // Randomize animation properties
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 150 + 50; // 50 to 200px
                const translateX = Math.cos(angle) * distance;
                const translateY = Math.sin(angle) * distance;
                const rotate = Math.random() * 720 - 360; // -360 to 360 degrees

                confetti.style.setProperty('--x', `${translateX}px`);
                confetti.style.setProperty('--y', `${translateY}px`);
                confetti.style.setProperty('--r', `${rotate}deg`);

                document.body.appendChild(confetti);

                // Remove confetti after animation
                confetti.addEventListener('animationend', () => {
                    confetti.remove();
                });
            }
        }


        // --- Kanban Board Logic ---

        let boardData = loadBoardState();
        let draggedCard = null; // Stores the currently dragged card element

        /**
         * Renders a single Kanban card.
         * @param {object} card - The card object {id, content}.
         * @returns {HTMLElement} The created card element.
         */
        function createCardElement(card) {
            const cardEl = document.createElement('div');
            cardEl.classList.add('kanban-card');
            cardEl.setAttribute('draggable', 'true');
            cardEl.dataset.cardId = card.id;

            const contentEl = document.createElement('div');
            contentEl.classList.add('card-content');
            contentEl.setAttribute('contenteditable', 'true');
            contentEl.textContent = card.content;

            // Save content on blur
            contentEl.addEventListener('blur', (e) => {
                const newContent = e.target.textContent.trim();
                if (newContent === '') {
                    // Prevent empty cards, revert to previous content or prompt
                    e.target.textContent = card.content;
                    showConfirmationModal('Empty Card', 'Card content cannot be empty. Reverting to previous content.').then(() => {
                        // No action needed after user closes alert
                    });
                    return;
                }
                if (newContent !== card.content) {
                    card.content = newContent;
                    saveBoardState(boardData);
                }
            });

            // Prevent new lines on Enter, but allow Shift+Enter for new lines
            contentEl.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault(); // Prevent new line
                    e.target.blur();    // Trigger blur event to save
                }
            });

            const deleteBtn = document.createElement('button');
            deleteBtn.classList.add('delete-card-btn');
            deleteBtn.textContent = 'x';
            deleteBtn.title = 'Delete card';
            deleteBtn.addEventListener('click', async () => {
                const confirmed = await showConfirmationModal(
                    'Delete Card',
                    'Are you sure you want to delete this card? This action cannot be undone.'
                );
                if (confirmed) {
                    deleteCard(card.id, cardEl.closest('.kanban-column').dataset.columnId);
                }
            });

            cardEl.appendChild(contentEl);
            cardEl.appendChild(deleteBtn);

            // Drag events
            cardEl.addEventListener('dragstart', (e) => {
                draggedCard = cardEl;
                cardEl.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', card.id); // Set data for drag operation
            });

            cardEl.addEventListener('dragend', () => {
                cardEl.classList.remove('dragging');
                draggedCard = null;
            });

            return cardEl;
        }

        /**
         * Renders a single Kanban column.
         * @param {object} column - The column object {id, title}.
         * @returns {HTMLElement} The created column element.
         */
        function createColumnElement(column) {
            const columnEl = document.createElement('div');
            columnEl.classList.add('kanban-column');
            columnEl.dataset.columnId = column.id;

            const headerEl = document.createElement('h2');
            headerEl.classList.add('kanban-column-header');
            headerEl.textContent = column.title;

            const cardsContainer = document.createElement('div');
            cardsContainer.classList.add('cards-container', 'flex', 'flex-col', 'gap-3', 'flex-grow');

            // Add existing cards to the column
            (boardData[column.id] || []).forEach(card => {
                cardsContainer.appendChild(createCardElement(card));
            });

            const addCardBtn = document.createElement('button');
            addCardBtn.classList.add('add-card-btn', 'mt-4', 'w-full');
            addCardBtn.textContent = '+ Add Card';
            addCardBtn.addEventListener('click', () => addCard(column.id));

            columnEl.appendChild(headerEl);
            columnEl.appendChild(cardsContainer);
            columnEl.appendChild(addCardBtn);

            // Drag and Drop events for columns
            columnEl.addEventListener('dragover', (e) => {
                e.preventDefault(); // Allow drop
                const draggingCard = document.querySelector('.kanban-card.dragging');
                if (draggingCard && draggingCard.closest('.kanban-column') !== columnEl) {
                    columnEl.classList.add('drag-over');
                }
                const afterElement = getDragAfterElement(cardsContainer, e.clientY);
                if (afterElement == null) {
                    cardsContainer.appendChild(draggingCard);
                } else {
                    cardsContainer.insertBefore(draggingCard, afterElement);
                }
            });

            columnEl.addEventListener('dragleave', () => {
                columnEl.classList.remove('drag-over');
            });

            columnEl.addEventListener('drop', (e) => {
                e.preventDefault();
                columnEl.classList.remove('drag-over');

                if (draggedCard) {
                    const cardId = draggedCard.dataset.cardId;
                    const oldColumnId = getColumnIdFromCardElement(draggedCard);
                    const newColumnId = columnEl.dataset.columnId;

                    // Update boardData
                    if (oldColumnId && newColumnId && oldColumnId !== newColumnId) {
                        const cardIndex = boardData[oldColumnId].findIndex(c => c.id === cardId);
                        if (cardIndex > -1) {
                            const [card] = boardData[oldColumnId].splice(cardIndex, 1);

                            // Find the correct insertion point in the new column based on current DOM order
                            const newCardsOrder = Array.from(cardsContainer.children)
                                .filter(el => el.classList.contains('kanban-card'))
                                .map(el => el.dataset.cardId);

                            const insertIndex = newCardsOrder.indexOf(cardId);
                            if (insertIndex !== -1) {
                                boardData[newColumnId].splice(insertIndex, 0, card);
                            } else {
                                boardData[newColumnId].push(card); // Fallback to push if not found (shouldn't happen with correct drag logic)
                            }

                            saveBoardState(boardData);

                            // Trigger confetti if moved to 'Done' column
                            if (newColumnId === 'done') {
                                const rect = draggedCard.getBoundingClientRect();
                                triggerConfetti(rect.left + rect.width / 2, rect.top + rect.height / 2);
                            }
                        }
                    }
                }
            });

            return columnEl;
        }

        /**
         * Gets the column ID from a card element's parent.
         * @param {HTMLElement} cardEl - The card element.
         * @returns {string|null} The column ID or null if not found.
         */
        function getColumnIdFromCardElement(cardEl) {
            const columnEl = cardEl.closest('.kanban-column');
            return columnEl ? columnEl.dataset.columnId : null;
        }

        /**
         * Determines where to insert a dragged element within a container.
         * @param {HTMLElement} container - The container element (e.g., cards-container).
         * @param {number} y - The Y coordinate of the mouse pointer.
         * @returns {HTMLElement|null} The element before which the dragged item should be inserted, or null if it should be appended.
         */
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.kanban-card:not(.dragging)')];

            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        /**
         * Adds a new card to a specified column.
         * @param {string} columnId - The ID of the column to add the card to.
         */
        function addCard(columnId) {
            const newCard = {
                id: generateUniqueId(),
                content: 'New Task'
            };
            boardData[columnId].push(newCard);
            saveBoardState(boardData);

            const columnEl = document.querySelector(`[data-column-id="${columnId}"]`);
            const cardsContainer = columnEl.querySelector('.cards-container');
            const newCardEl = createCardElement(newCard);
            cardsContainer.appendChild(newCardEl);

            // Focus and select the content of the new card for immediate editing
            const contentEl = newCardEl.querySelector('.card-content');
            contentEl.focus();
            document.execCommand('selectAll', false, null); // Select all text
        }

        /**
         * Deletes a card from the board.
         * @param {string} cardId - The ID of the card to delete.
         * @param {string} columnId - The ID of the column the card belongs to.
         */
        function deleteCard(cardId, columnId) {
            boardData[columnId] = boardData[columnId].filter(card => card.id !== cardId);
            saveBoardState(boardData);
            document.querySelector(`[data-card-id="${cardId}"]`).remove();
        }

        /**
         * Initializes the Kanban board by rendering all columns and cards.
         */
        function initializeBoard() {
            const kanbanBoardEl = document.getElementById('kanbanBoard');
            kanbanBoardEl.innerHTML = ''; // Clear existing content

            COLUMNS.forEach(column => {
                kanbanBoardEl.appendChild(createColumnElement(column));
            });
        }

        // Initialize the board when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', initializeBoard);
    </script>
</body>
</html>