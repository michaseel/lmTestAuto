<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Vanilla JS Kanban Board</title>

  <!-- Tailwind CDN for utility classes -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    /* Subtle transitions for cards and columns */
    .kanban-card {
      transition: transform 150ms cubic-bezier(.2,.8,.2,1), box-shadow 150ms;
    }
    .kanban-card:active {
      transform: scale(.99);
    }
    .kanban-card.dragging {
      opacity: .6;
      transform: rotate(2deg) scale(1.02);
      box-shadow: 0 12px 30px rgba(15,23,42,.25);
    }
    .column-highlight {
      box-shadow: inset 0 0 0 2px rgba(99,102,241,.08), 0 6px 18px rgba(99,102,241,.06);
      border-radius: .6rem;
      transition: box-shadow .15s;
    }
    .drop-placeholder {
      height: 3.2rem;
      margin: .5rem 0;
      border-radius: .5rem;
      background: linear-gradient(90deg, rgba(99,102,241,.12), rgba(16,185,129,.06));
      border: 1px dashed rgba(99,102,241,.18);
    }

    /* Confetti canvas sits on top */
    #confetti-canvas {
      pointer-events: none;
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      z-index: 60;
    }

    /* Small UI niceties */
    .muted {
      color: rgba(15,23,42,.45);
    }

    /* Custom scrollbar for columns */
    .col-scroll::-webkit-scrollbar {
      height: 8px;
      width: 8px;
    }
    .col-scroll::-webkit-scrollbar-thumb {
      background: rgba(15,23,42,.12);
      border-radius: 8px;
    }
  </style>
</head>
<body class="bg-gradient-to-b from-indigo-50 via-white to-green-50 min-h-screen antialiased">

  <!-- App container -->
  <div class="max-w-7xl mx-auto p-6">
    <header class="flex items-center justify-between mb-6">
      <div>
        <h1 class="text-3xl font-extrabold text-slate-900">Kanban Board</h1>
        <p class="text-sm muted">Drag, edit, and manage tasks — state persists locally.</p>
      </div>
      <div class="flex items-center space-x-2">
        <button id="resetBtn" class="inline-flex items-center gap-2 px-4 py-2 bg-white border border-slate-200 rounded-lg shadow-sm hover:shadow-md text-sm">
          <!-- refresh icon -->
          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-slate-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582M20 20v-5h-.581M20 4a8 8 0 10-3.6 15.2M4 20a8 8 0 103.6-15.2"/></svg>
          Reset
        </button>
      </div>
    </header>

    <!-- Board -->
    <main id="board" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
      <!-- Columns will be injected here -->
    </main>
  </div>

  <!-- Confetti canvas -->
  <canvas id="confetti-canvas"></canvas>

  <!-- Custom modal for delete confirmation (no window.alert) -->
  <div id="modalOverlay" class="fixed inset-0 bg-black/30 hidden items-center justify-center z-50">
    <div class="bg-white rounded-xl shadow-xl w-11/12 max-w-sm p-6">
      <h3 class="text-lg font-semibold text-slate-900 mb-3">Confirm deletion</h3>
      <p class="text-sm muted mb-5">Are you sure you want to delete this card? This action cannot be undone.</p>
      <div class="flex justify-end gap-3">
        <button id="modalCancel" class="px-4 py-2 rounded-md text-sm bg-gray-100">Cancel</button>
        <button id="modalConfirm" class="px-4 py-2 rounded-md bg-red-500 text-white">Delete</button>
      </div>
    </div>
  </div>

  <!-- Inline script contains full functionality -->
  <script>
  /* 
    Vanilla JS Kanban Board
    - Single-file app using Tailwind for styling via CDN
    - Features: drag & drop, in-place editing, persistent storage, delete confirmation modal,
      add card per column, transitions, and confetti when a card moves to Done.
    - Thorough comments included.
  */

  (function () {
    // Namespace key for localStorage to avoid collisions
    const STORAGE_KEY = 'kanban_v1_state';

    // Column identifiers and display names
    const COLUMNS = [
      { id: 'backlog', title: 'Backlog', accent: 'bg-indigo-100', color: 'indigo' },
      { id: 'inProgress', title: 'In Progress', accent: 'bg-yellow-100', color: 'yellow' },
      { id: 'review', title: 'Review', accent: 'bg-pink-100', color: 'pink' },
      { id: 'done', title: 'Done', accent: 'bg-green-100', color: 'green' }
    ];

    // App state structure
    let state = {
      columns: {
        backlog: [],
        inProgress: [],
        review: [],
        done: []
      }
    };

    // DOM references
    const board = document.getElementById('board');
    const modalOverlay = document.getElementById('modalOverlay');
    const modalConfirmBtn = document.getElementById('modalConfirm');
    const modalCancelBtn = document.getElementById('modalCancel');
    const resetBtn = document.getElementById('resetBtn');
    const confettiCanvas = document.getElementById('confetti-canvas');

    // Drag state helpers
    let dragState = {
      cardId: null,
      fromColumn: null,
      draggingEl: null,
      placeholder: null
    };

    // Initialize confetti engine
    const confetti = createConfettiEngine(confettiCanvas);

    // Utility: generate unique ID for cards
    function uid(prefix = 'c') {
      return prefix + '_' + Math.random().toString(36).slice(2, 9);
    }

    // Save current state to localStorage
    function saveState() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch (e) {
        console.error('Failed to save state', e);
      }
    }

    // Load state from localStorage, or initialize with dummy cards if empty
    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (raw) {
          state = JSON.parse(raw);
        } else {
          // Create some dummy cards if no state exists
          state = {
            columns: {
              backlog: [
                { id: uid(), content: 'Design landing page hero section' },
                { id: uid(), content: 'Create project roadmap' }
              ],
              inProgress: [
                { id: uid(), content: 'Implement authentication flow' }
              ],
              review: [
                { id: uid(), content: 'UX review for settings panel' }
              ],
              done: [
                { id: uid(), content: 'Set up project repo & CI' }
              ]
            }
          };
          saveState();
        }
      } catch (e) {
        console.error('Failed to load state', e);
      }
    }

    // Render the entire board
    function renderBoard() {
      // Clear board
      board.innerHTML = '';

      // Create columns
      COLUMNS.forEach(col => {
        const colEl = document.createElement('section');
        colEl.className = 'bg-white rounded-2xl p-4 flex flex-col shadow-sm min-h-[16rem]';
        colEl.dataset.columnId = col.id;

        // Header area with title and add button
        colEl.innerHTML = `
          <div class="flex items-start justify-between gap-2 mb-3">
            <div class="flex items-center gap-3">
              <div class="w-3 h-3 rounded-full ${col.accent}"></div>
              <div>
                <h2 class="text-sm font-semibold text-slate-800">${col.title}</h2>
                <p class="text-xs muted">${state.columns[col.id].length} ${state.columns[col.id].length === 1 ? 'card' : 'cards'}</p>
              </div>
            </div>
            <div class="flex items-center gap-2">
              <button class="add-card-btn inline-flex items-center px-2 py-1 text-xs rounded-md bg-${col.color}-50 text-${col.color}-700 hover:brightness-95">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" /></svg>
                Add
              </button>
            </div>
          </div>
          <div class="col-scroll overflow-auto min-h-[10rem] max-h-[60vh] px-1 py-1 space-y-2 flex-1" data-list></div>
        `;

        // Attach DnD handlers to column element
        const listEl = colEl.querySelector('[data-list]');
        attachColumnDragHandlers(colEl, listEl);

        // Render cards for this column
        const cards = state.columns[col.id] || [];
        cards.forEach(card => {
          const cardEl = createCardElement(card, col.id);
          listEl.appendChild(cardEl);
        });

        board.appendChild(colEl);

        // Add button event: show inline composer for a new card
        const addBtn = colEl.querySelector('.add-card-btn');
        addBtn.addEventListener('click', () => showInlineComposer(listEl, col.id));
      });
    }

    // Create a card DOM element from card data
    function createCardElement(card, columnId) {
      const cardEl = document.createElement('div');
      cardEl.className = 'kanban-card bg-gradient-to-r from-white/60 to-white/80 border border-slate-100 rounded-xl p-3 shadow-sm hover:shadow-md cursor-grab transition';
      cardEl.draggable = true;
      cardEl.dataset.cardId = card.id;
      cardEl.dataset.columnId = columnId;

      // Card inner HTML: content area (editable), and small actions (edit/delete/drag handle)
      cardEl.innerHTML = `
        <div class="flex items-start justify-between gap-2">
          <div class="flex-1">
            <div class="card-content text-sm text-slate-800" contenteditable="false" spellcheck="false">${escapeHtml(card.content)}</div>
            <div class="text-xs muted mt-2">${formatCreatedSnippet(card)}</div>
          </div>
          <div class="flex flex-col items-end gap-2 ml-3">
            <button class="edit-btn p-1 rounded-md hover:bg-slate-100" title="Edit">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-slate-500" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536M10.5 13.5L18 6l-1.5-1.5L9 12l1.5 1.5zM3 21h6v-3H3v3z"/></svg>
            </button>
            <button class="delete-btn p-1 rounded-md hover:bg-slate-100 text-red-500" title="Delete">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5-4h4l1 4H9l1-4z"/></svg>
            </button>
            <div class="drag-handle p-1 rounded-md muted" title="Drag">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-slate-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 9h.01M12 9h.01M16 9h.01M8 13h.01M12 13h.01M16 13h.01"/></svg>
            </div>
          </div>
        </div>
      `;

      // References to inner elements
      const contentEl = cardEl.querySelector('.card-content');
      const editBtn = cardEl.querySelector('.edit-btn');
      const deleteBtn = cardEl.querySelector('.delete-btn');

      // Drag event handlers
      cardEl.addEventListener('dragstart', (e) => {
        dragState.cardId = card.id;
        dragState.fromColumn = columnId;
        dragState.draggingEl = cardEl;
        cardEl.classList.add('dragging');

        // set data transfer to support DnD between columns
        e.dataTransfer.setData('text/plain', JSON.stringify({ id: card.id, from: columnId }));
        // set an empty drag image for better visuals on some browsers
        const crt = cardEl.cloneNode(true);
        crt.style.position = 'absolute';
        crt.style.top = '-9999px';
        document.body.appendChild(crt);
        e.dataTransfer.setDragImage(crt, 10, 10);
        setTimeout(() => document.body.removeChild(crt), 0);
      });

      cardEl.addEventListener('dragend', () => {
        // cleanup dragging state and placeholder if lingering
        if (dragState.placeholder && dragState.placeholder.parentElement) {
          dragState.placeholder.remove();
        }
        if (dragState.draggingEl) {
          dragState.draggingEl.classList.remove('dragging');
        }
        dragState = { cardId: null, fromColumn: null, draggingEl: null, placeholder: null };
        // ensure UI reflects up-to-date state
        renderBoard();
      });

      // Edit button toggles edit-mode
      editBtn.addEventListener('click', () => {
        enterEditMode(card.id, contentEl);
      });

      // Delete button shows custom confirmation modal
      deleteBtn.addEventListener('click', async () => {
        const confirmed = await showConfirmationModal();
        if (confirmed) {
          deleteCard(card.id);
        }
      });

      // Double-click to edit as well
      contentEl.addEventListener('dblclick', () => enterEditMode(card.id, contentEl));

      // Prevent dragging when interacting with contenteditable
      contentEl.addEventListener('mousedown', (e) => {
        // stop propagation to avoid ghost dragging when selecting text
        e.stopPropagation();
      });

      return cardEl;
    }

    // Escape simple HTML to avoid injection when rendering from storage
    function escapeHtml(str) {
      return String(str)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;');
    }

    // Format a small snippet for card created/modified time (here simply blank or "•")
    function formatCreatedSnippet(card) {
      // We only store content, but show a subtle handle - could be replaced with timestamps
      return '●';
    }

    // Show an inline composer in a column to add a new card (no window.prompt)
    function showInlineComposer(listEl, columnId) {
      // If there's already a composer, focus it
      if (listEl.querySelector('.composer')) {
        listEl.querySelector('.composer textarea, .composer .composer-input')?.focus();
        return;
      }

      // Create composer element
      const composer = document.createElement('div');
      composer.className = 'composer bg-slate-50 border border-slate-100 rounded-xl p-3 shadow-sm';
      composer.innerHTML = `
        <div class="flex flex-col">
          <textarea class="composer-input resize-none w-full min-h-[3.2rem] p-2 text-sm rounded-md focus:outline-none" placeholder="Enter card title..." maxlength="500"></textarea>
          <div class="flex items-center justify-end gap-2 mt-2">
            <button class="cancel-btn text-sm px-3 py-1 rounded-md">Cancel</button>
            <button class="add-btn bg-indigo-600 text-white px-3 py-1 rounded-md">Add card</button>
          </div>
        </div>
      `;

      // Add composer at top of list
      listEl.prepend(composer);

      const textarea = composer.querySelector('.composer-input');
      textarea.focus();

      // Add / Cancel button handlers
      composer.querySelector('.cancel-btn').addEventListener('click', () => {
        composer.remove();
      });

      composer.querySelector('.add-btn').addEventListener('click', () => {
        const content = textarea.value.trim();
        if (!content) {
          // simple visual hint
          textarea.classList.add('ring-2', 'ring-red-300');
          setTimeout(() => textarea.classList.remove('ring-2', 'ring-red-300'), 800);
          textarea.focus();
          return;
        }
        addCard(columnId, content);
        composer.remove();
      });

      // Enter to add, Escape to cancel
      textarea.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          composer.querySelector('.add-btn').click();
        } else if (e.key === 'Escape') {
          composer.querySelector('.cancel-btn').click();
        }
      });
    }

    // Add a new card to a column
    function addCard(columnId, content, atIndex = 0) {
      const newCard = { id: uid(), content: content };
      // Insert at top by default
      state.columns[columnId].splice(atIndex, 0, newCard);
      saveState();
      renderBoard();
    }

    // Delete a card by id
    function deleteCard(cardId) {
      for (const col of Object.keys(state.columns)) {
        const idx = state.columns[col].findIndex(c => c.id === cardId);
        if (idx !== -1) {
          state.columns[col].splice(idx, 1);
          saveState();
          renderBoard();
          return;
        }
      }
    }

    // Enter edit mode for a particular card content element
    function enterEditMode(cardId, contentEl) {
      // Find card data
      const cardData = findCardById(cardId);
      if (!cardData) return;

      // Make editable
      contentEl.contentEditable = 'true';
      contentEl.classList.add('ring-2', 'ring-indigo-200', 'rounded-md', 'p-1');
      contentEl.focus();

      // Create small toolbar for save/cancel
      const toolbar = document.createElement('div');
      toolbar.className = 'mt-2 flex items-center justify-end gap-2';
      toolbar.innerHTML = `
        <button class="cancel-edit text-sm px-3 py-1 rounded-md">Cancel</button>
        <button class="save-edit bg-indigo-600 text-white px-3 py-1 rounded-md">Save</button>
      `;
      contentEl.parentElement.appendChild(toolbar);

      // Save function
      function saveEdit() {
        const newText = contentEl.innerText.trim();
        if (!newText) {
          contentEl.classList.add('ring-2', 'ring-red-300');
          setTimeout(() => contentEl.classList.remove('ring-2', 'ring-red-300'), 800);
          contentEl.focus();
          return;
        }
        // update state
        cardData.content = newText;
        saveState();
        exit();
      }

      // Cancel edit: revert to original content
      function cancelEdit() {
        contentEl.innerText = cardData.content;
        exit();
      }

      function exit() {
        contentEl.contentEditable = 'false';
        contentEl.classList.remove('ring-2', 'ring-indigo-200', 'rounded-md', 'p-1');
        toolbar.remove();
        // Re-render to ensure sanitization & UI consistency
        renderBoard();
      }

      // Toolbar handlers
      toolbar.querySelector('.save-edit').addEventListener('click', saveEdit);
      toolbar.querySelector('.cancel-edit').addEventListener('click', cancelEdit);

      // Key handling: Enter = save, Escape = cancel
      function keyHandler(evt) {
        if (evt.key === 'Enter' && !evt.shiftKey) {
          evt.preventDefault();
          saveEdit();
        } else if (evt.key === 'Escape') {
          evt.preventDefault();
          cancelEdit();
        }
      }
      contentEl.addEventListener('keydown', keyHandler);

      // On blur, save as well (common UX)
      contentEl.addEventListener('blur', (e) => {
        // small timeout to allow click on toolbar
        setTimeout(() => {
          if (document.activeElement && toolbar.contains(document.activeElement)) return;
          if (contentEl.contentEditable === 'true') saveEdit();
        }, 150);
      }, { once: true });
    }

    // Find card object by id and return reference {card, columnId}
    function findCardById(cardId) {
      for (const [colId, arr] of Object.entries(state.columns)) {
        const found = arr.find(c => c.id === cardId);
        if (found) return found;
      }
      return null;
    }

    // Move a card to a target column at a specific index
    function moveCard(cardId, toColumn, toIndex = null) {
      // Find and remove from current column
      let movedCard = null;
      let fromColumn = null;
      for (const col of Object.keys(state.columns)) {
        const idx = state.columns[col].findIndex(c => c.id === cardId);
        if (idx !== -1) {
          movedCard = state.columns[col].splice(idx, 1)[0];
          fromColumn = col;
          break;
        }
      }
      if (!movedCard) return;

      // If no index provided, append to end
      if (toIndex === null || toIndex < 0 || toIndex > state.columns[toColumn].length) {
        state.columns[toColumn].push(movedCard);
      } else {
        state.columns[toColumn].splice(toIndex, 0, movedCard);
      }

      saveState();
      renderBoard();

      // Trigger confetti if moved into Done from a different column
      if (toColumn === 'done' && fromColumn !== 'done') {
        confetti.fire();
      }
    }

    // Attach drag handlers to a column element and its list container
    function attachColumnDragHandlers(columnEl, listEl) {
      // Calculate closest insertion index based on mouse Y
      function getInsertionIndex(y) {
        const children = Array.from(listEl.querySelectorAll('.kanban-card'));
        if (children.length === 0) return 0;
        for (let i = 0; i < children.length; i++) {
          const rect = children[i].getBoundingClientRect();
          if (y < rect.top + rect.height / 2) return i;
        }
        return children.length;
      }

      // When a draggable enters the column, highlight
      columnEl.addEventListener('dragenter', (e) => {
        e.preventDefault();
        columnEl.classList.add('column-highlight');
      });

      columnEl.addEventListener('dragover', (e) => {
        e.preventDefault();
        // compute insertion position and show a placeholder
        const y = e.clientY;
        const idx = getInsertionIndex(y);

        // remove old placeholder
        if (dragState.placeholder && dragState.placeholder.parentElement) {
          dragState.placeholder.remove();
        }

        // create placeholder
        const placeholder = document.createElement('div');
        placeholder.className = 'drop-placeholder';
        dragState.placeholder = placeholder;

        const children = Array.from(listEl.querySelectorAll('.kanban-card'));
        if (children.length === 0) {
          listEl.appendChild(placeholder);
        } else if (idx >= children.length) {
          children[children.length - 1].after(placeholder);
        } else {
          children[idx].before(placeholder);
        }
      });

      columnEl.addEventListener('dragleave', (e) => {
        // If leaving to somewhere outside the column, remove highlight and placeholder
        // Use relatedTarget to ensure not leaving to a child
        const rt = e.relatedTarget;
        if (!columnEl.contains(rt)) {
          columnEl.classList.remove('column-highlight');
          if (dragState.placeholder && dragState.placeholder.parentElement) {
            dragState.placeholder.remove();
            dragState.placeholder = null;
          }
        }
      });

      columnEl.addEventListener('drop', (e) => {
        e.preventDefault();
        columnEl.classList.remove('column-highlight');

        // read dropped data
        let data = null;
        try {
          data = JSON.parse(e.dataTransfer.getData('text/plain'));
        } catch {
          // fallback to dragState if dataTransfer isn't available
          data = { id: dragState.cardId, from: dragState.fromColumn };
        }
        const cardId = data?.id;
        if (!cardId) return;

        // Determine index based on placeholder position if present
        let insertIndex = null;
        if (dragState.placeholder && dragState.placeholder.parentElement === listEl) {
          // count how many cards are before placeholder
          const children = Array.from(listEl.querySelectorAll('.kanban-card, .composer'));
          insertIndex = Array.from(listEl.children).indexOf(dragState.placeholder);
        } else {
          // If no placeholder, append
          insertIndex = state.columns[columnEl.dataset.columnId].length;
        }

        // perform move
        moveCard(cardId, columnEl.dataset.columnId, insertIndex);

        // cleanup placeholder
        if (dragState.placeholder && dragState.placeholder.parentElement) {
          dragState.placeholder.remove();
          dragState.placeholder = null;
        }
      });
    }

    // Custom modal confirmation returning a Promise<boolean>
    function showConfirmationModal() {
      return new Promise((resolve) => {
        modalOverlay.classList.remove('hidden');
        modalOverlay.classList.add('flex');

        function cleanup(result) {
          modalOverlay.classList.add('hidden');
          modalOverlay.classList.remove('flex');
          modalConfirmBtn.removeEventListener('click', onConfirm);
          modalCancelBtn.removeEventListener('click', onCancel);
          resolve(result);
        }
        function onConfirm() { cleanup(true); }
        function onCancel() { cleanup(false); }

        modalConfirmBtn.addEventListener('click', onConfirm);
        modalCancelBtn.addEventListener('click', onCancel);
      });
    }

    // Reset board to initial dummy state
    function resetBoard() {
      localStorage.removeItem(STORAGE_KEY);
      loadState();
      renderBoard();
    }

    // Wire up reset button
    resetBtn.addEventListener('click', async () => {
      const confirmed = await showConfirmationModal();
      if (confirmed) resetBoard();
    });

    // Confetti engine factory
    function createConfettiEngine(canvas) {
      // Basic particle confetti system that shoots multi-colored pieces and fades them.
      const ctx = canvas.getContext('2d');
      let W = (canvas.width = window.innerWidth);
      let H = (canvas.height = window.innerHeight);
      let particles = [];
      let running = false;
      const PI2 = Math.PI * 2;
      const colors = ['#06b6d4', '#8b5cf6', '#ef4444', '#f97316', '#10b981', '#f59e0b', '#ec4899'];

      // Handle resize
      window.addEventListener('resize', () => {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
      });

      function rand(min, max) { return Math.random() * (max - min) + min; }

      function createParticle(x, y) {
        return {
          x: x,
          y: y,
          vx: rand(-6, 6),
          vy: rand(-12, -4),
          size: rand(6, 12),
          gravity: rand(0.15, 0.35),
          rotation: rand(0, PI2),
          vr: rand(-0.2, 0.2),
          color: colors[Math.floor(rand(0, colors.length))],
          life: 0,
          ttl: Math.floor(rand(60, 120))
        };
      }

      function update() {
        ctx.clearRect(0, 0, W, H);
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.vy += p.gravity;
          p.x += p.vx;
          p.y += p.vy;
          p.rotation += p.vr;
          p.life++;

          // fade out
          const alpha = 1 - p.life / p.ttl;
          ctx.save();
          ctx.globalAlpha = Math.max(alpha, 0);
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rotation);
          ctx.fillStyle = p.color;
          // draw rectangle confetti
          ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 0.6);
          ctx.restore();

          if (p.life >= p.ttl || p.y > H + 100) {
            particles.splice(i, 1);
          }
        }

        if (particles.length > 0) {
          requestAnimationFrame(update);
        } else {
          running = false;
          ctx.clearRect(0, 0, W, H);
        }
      }

      return {
        // fire confetti burst from top center (or optionally provided coords)
        fire(x = W / 2, y = H / 4) {
          // create a burst of particles
          const count = 80;
          for (let i = 0; i < count; i++) {
            particles.push(createParticle(x + rand(-40, 40), y + rand(-40, 40)));
          }
          if (!running) {
            running = true;
            requestAnimationFrame(update);
          }
        }
      };
    }

    // Initial load + render
    loadState();
    renderBoard();

    // Accessibility: allow dragging via keyboard? (not implemented here due to scope)
    // The app primarily focuses on pointer-based DnD.

    // End of main IIFE
  })();
  </script>
</body>
</html>