```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Vibrant Kanban Board</title>
  <!-- Tailwind CSS via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Confetti via CDN -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
  <script>
    // Tailwind config for vibrant colors
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            backlog: '#FEE2E2',
            'backlog-border': '#FECACA',
            'backlog-text': '#B91C1C',
            inprogress: '#DBEAFE',
            'inprogress-border': '#BFDBFE',
            'inprogress-text': '#1D4ED8',
            review: '#ECFDF5',
            'review-border': '#D1FAE5',
            'review-text': '#047857',
            done: '#FDF4FF',
            'done-border': '#FCE7F3',
            'done-text': '#9D174D',
            card: '#FFFFFF',
            'card-shadow': 'rgba(0,0,0,0.1)',
          }
        }
      }
    }
  </script>
  <style>
    /* Smooth transitions for cards and columns */
    .kanban-column {
      transition: all 0.2s ease;
    }
    .kanban-card {
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .kanban-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px var(--card-shadow);
    }
    /* Scrollbar styling */
    .kanban-column-content {
      scrollbar-width: thin;
      scrollbar-color: #cbd5e1 #f8fafc;
    }
    .kanban-column-content::-webkit-scrollbar {
      width: 6px;
    }
    .kanban-column-content::-webkit-scrollbar-track {
      background: #f8fafc;
    }
    .kanban-column-content::-webkit-scrollbar-thumb {
      background-color: #cbd5e1;
      border-radius: 3px;
    }
  </style>
</head>
<body class="bg-gradient-to-br from-indigo-50 to-purple-50 min-h-screen p-4 md:p-8">
  <div class="max-w-7xl mx-auto">
    <header class="mb-8 text-center">
      <h1 class="text-3xl md:text-4xl font-bold text-gray-800">Vibrant Kanban Board</h1>
      <p class="text-gray-600 mt-2">Drag, edit, and organize your tasks</p>
    </header>

    <!-- Kanban Board -->
    <div id="kanban-board" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 md:gap-6">
      <!-- Columns will be generated by JavaScript -->
    </div>
  </div>

  <!-- Modal for editing/adding cards -->
  <div id="cardModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
    <div class="bg-white rounded-xl shadow-xl w-full max-w-md p-6">
      <h2 id="modalTitle" class="text-xl font-semibold text-gray-800 mb-4">Edit Card</h2>
      <textarea id="cardContent" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:outline-none" rows="4" placeholder="Enter task description..."></textarea>
      <div class="mt-4 flex justify-end space-x-3">
        <button id="cancelBtn" class="px-4 py-2 text-gray-600 hover:text-gray-800 font-medium">Cancel</button>
        <button id="saveBtn" class="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 font-medium">Save</button>
      </div>
    </div>
  </div>

  <script>
    // ================================
    // KANBAN BOARD IMPLEMENTATION
    // ================================

    // Constants
    const COLUMNS = [
      { id: 'backlog', title: 'Backlog', color: 'backlog' },
      { id: 'inprogress', title: 'In Progress', color: 'inprogress' },
      { id: 'review', title: 'Review', color: 'review' },
      { id: 'done', title: 'Done', color: 'done' }
    ];

    // LocalStorage key (namespace to avoid conflicts)
    const STORAGE_KEY = 'kanbanBoard_v1';

    // State management
    let boardState = loadBoardState();
    let currentEditingCard = null; // Tracks the card being edited
    let dragSourceCard = null;     // Tracks the card being dragged

    // DOM Elements
    const boardEl = document.getElementById('kanban-board');
    const modalEl = document.getElementById('cardModal');
    const modalTitleEl = document.getElementById('modalTitle');
    const cardContentEl = document.getElementById('cardContent');
    const cancelBtn = document.getElementById('cancelBtn');
    const saveBtn = document.getElementById('saveBtn');

    // Initialize the board
    initBoard();

    // ================================
    // STATE PERSISTENCE
    // ================================

    /**
     * Load board state from localStorage or return default with dummy cards
     * @returns {Object} board state with columns and cards
     */
    function loadBoardState() {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        try {
          return JSON.parse(saved);
        } catch (e) {
          console.warn('Failed to parse saved state, using default');
        }
      }

      // Create default state with dummy cards
      const defaultState = {};
      COLUMNS.forEach(col => {
        defaultState[col.id] = [];
      });

      // Add dummy cards to Backlog
      const dummyCards = [
        'Create project wireframes',
        'Research competitor features',
        'Set up development environment',
        'Draft user stories',
        'Schedule team kickoff meeting'
      ];
      dummyCards.forEach((text, idx) => {
        defaultState.backlog.push({
          id: `card-${Date.now()}-${idx}`,
          text: text
        });
      });

      return defaultState;
    }

    /**
     * Save current board state to localStorage
     */
    function saveBoardState() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(boardState));
    }

    // ================================
    // BOARD RENDERING
    // ================================

    /**
     * Initialize and render the entire board
     */
    function initBoard() {
      boardEl.innerHTML = '';

      COLUMNS.forEach(col => {
        const columnEl = createColumnElement(col);
        boardEl.appendChild(columnEl);
      });

      // Attach modal event listeners
      cancelBtn.addEventListener('click', closeModal);
      saveBtn.addEventListener('click', saveCard);
    }

    /**
     * Create a single column element
     * @param {Object} col - column definition
     * @returns {HTMLElement} column DOM element
     */
    function createColumnElement(col) {
      const columnEl = document.createElement('div');
      columnEl.className = `kanban-column flex flex-col rounded-xl overflow-hidden shadow-md`;
      columnEl.style.backgroundColor = `rgb(var(--color-${col.color}-50))`;
      columnEl.style.borderColor = `rgb(var(--color-${col.color}-200))`;
      columnEl.dataset.column = col.id;

      // Column header
      const headerEl = document.createElement('div');
      headerEl.className = 'p-4 border-b font-bold flex justify-between items-center';
      headerEl.style.borderColor = `rgb(var(--color-${col.color}-200))`;
      headerEl.innerHTML = `
        <span class="text-lg" style="color: rgb(var(--color-${col.color}-700))">${col.title}</span>
        <span class="bg-white px-2 py-1 rounded-full text-sm font-medium" style="color: rgb(var(--color-${col.color}-600))">${boardState[col.id].length}</span>
      `;

      // Add card button
      const addBtn = document.createElement('button');
      addBtn.className = 'mt-2 w-full py-2 bg-white text-sm font-medium rounded-lg hover:bg-gray-50 transition';
      addBtn.style.color = `rgb(var(--color-${col.color}-600))`;
      addBtn.textContent = '+ Add Card';
      addBtn.addEventListener('click', () => openModal(null, col.id));

      // Cards container
      const cardsContainer = document.createElement('div');
      cardsContainer.className = 'kanban-column-content flex-1 p-2 overflow-y-auto max-h-[60vh]';
      cardsContainer.dataset.column = col.id;

      // Render existing cards
      boardState[col.id].forEach(card => {
        const cardEl = createCardElement(card, col.id);
        cardsContainer.appendChild(cardEl);
      });

      // Enable drop on column
      setupDropZone(cardsContainer, col.id);

      columnEl.appendChild(headerEl);
      columnEl.appendChild(cardsContainer);
      columnEl.appendChild(addBtn);

      return columnEl;
    }

    /**
     * Create a single card element
     * @param {Object} card - card data
     * @param {string} columnId - current column ID
     * @returns {HTMLElement} card DOM element
     */
    function createCardElement(card, columnId) {
      const cardEl = document.createElement('div');
      cardEl.className = 'kanban-card bg-white p-3 mb-3 rounded-lg shadow-sm cursor-move relative';
      cardEl.dataset.cardId = card.id;
      cardEl.dataset.column = columnId;

      // Card content (editable via modal)
      const contentEl = document.createElement('p');
      contentEl.className = 'text-gray-700 whitespace-pre-wrap break-words';
      contentEl.textContent = card.text;
      contentEl.addEventListener('click', (e) => {
        e.stopPropagation();
        openModal(card, columnId);
      });

      // Delete button
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'absolute top-2 right-2 text-gray-400 hover:text-red-500 text-lg font-bold rounded-full w-6 h-6 flex items-center justify-center';
      deleteBtn.innerHTML = 'Ã—';
      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (confirmDelete(card)) {
          deleteCard(card.id, columnId);
        }
      });

      cardEl.appendChild(contentEl);
      cardEl.appendChild(deleteBtn);

      // Enable drag
      setupDrag(cardEl, card, columnId);

      return cardEl;
    }

    // ================================
    // DRAG AND DROP FUNCTIONALITY
    // ================================

    /**
     * Setup drag events for a card
     * @param {HTMLElement} cardEl - card DOM element
     * @param {Object} card - card data
     * @param {string} columnId - current column ID
     */
    function setupDrag(cardEl, card, columnId) {
      cardEl.draggable = true;

      cardEl.addEventListener('dragstart', (e) => {
        dragSourceCard = { ...card, columnId };
        e.dataTransfer.setData('text/plain', card.id);
        // Add visual feedback
        cardEl.classList.add('opacity-50');
      });

      cardEl.addEventListener('dragend', () => {
        cardEl.classList.remove('opacity-50');
        dragSourceCard = null;
      });
    }

    /**
     * Setup drop zone for a column
     * @param {HTMLElement} dropZone - drop zone element
     * @param {string} columnId - target column ID
     */
    function setupDropZone(dropZone, columnId) {
      dropZone.addEventListener('dragover', (e) => {
        e.preventDefault(); // Necessary to allow drop
        dropZone.classList.add('bg-opacity-50');
      });

      dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('bg-opacity-50');
      });

      dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('bg-opacity-50');

        const cardId = e.dataTransfer.getData('text/plain');
        if (!cardId || !dragSourceCard || dragSourceCard.id !== cardId) return;

        // If moving to same column, do nothing
        if (dragSourceCard.columnId === columnId) return;

        // Move card in state
        moveCard(cardId, dragSourceCard.columnId, columnId);

        // Re-render only the affected columns
        reRenderColumn(dragSourceCard.columnId);
        reRenderColumn(columnId);

        // Trigger confetti if moved to Done
        if (columnId === 'done') {
          triggerConfetti();
        }
      });
    }

    /**
     * Move a card from one column to another
     * @param {string} cardId - ID of card to move
     * @param {string} fromColumn - source column ID
     * @param {string} toColumn - target column ID
     */
    function moveCard(cardId, fromColumn, toColumn) {
      // Find card in source column
      const cardIndex = boardState[fromColumn].findIndex(c => c.id === cardId);
      if (cardIndex === -1) return;

      const card = boardState[fromColumn][cardIndex];
      // Remove from source
      boardState[fromColumn].splice(cardIndex, 1);
      // Add to target
      boardState[toColumn].push(card);

      saveBoardState();
    }

    // ================================
    // CARD OPERATIONS
    // ================================

    /**
     * Open modal for adding/editing a card
     * @param {Object|null} card - card to edit (null for new card)
     * @param {string} columnId - column where card belongs
     */
    function openModal(card, columnId) {
      currentEditingCard = { card, columnId };
      modalTitleEl.textContent = card ? 'Edit Card' : 'Add Card';
      cardContentEl.value = card ? card.text : '';
      modalEl.classList.remove('hidden');
      cardContentEl.focus();
    }

    /**
     * Close the modal without saving
     */
    function closeModal() {
      modalEl.classList.add('hidden');
      currentEditingCard = null;
      cardContentEl.value = '';
    }

    /**
     * Save the card from modal (add or update)
     */
    function saveCard() {
      const content = cardContentEl.value.trim();
      if (!content) {
        // Optional: show validation message
        return;
      }

      const { card, columnId } = currentEditingCard;

      if (card) {
        // Update existing card
        const cardIndex = boardState[columnId].findIndex(c => c.id === card.id);
        if (cardIndex !== -1) {
          boardState[columnId][cardIndex].text = content;
        }
      } else {
        // Add new card
        const newCard = {
          id: `card-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          text: content
        };
        boardState[columnId].push(newCard);
      }

      saveBoardState();
      closeModal();
      reRenderColumn(columnId);
    }

    /**
     * Delete a card after confirmation
     * @param {string} cardId - ID of card to delete
     * @param {string} columnId - column ID
     */
    function deleteCard(cardId, columnId) {
      boardState[columnId] = boardState[columnId].filter(c => c.id !== cardId);
      saveBoardState();
      reRenderColumn(columnId);
    }

    /**
     * Show a custom confirmation dialog for deletion
     * @param {Object} card - card to delete
     * @returns {boolean} true if confirmed
     */
    function confirmDelete(card) {
      // Create a simple modal for confirmation
      const confirmEl = document.createElement('div');
      confirmEl.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      confirmEl.innerHTML = `
        <div class="bg-white rounded-xl p-6 max-w-sm w-full mx-4">
          <h3 class="text-lg font-medium text-gray-900 mb-2">Delete Card?</h3>
          <p class="text-gray-600 mb-4">"${card.text.substring(0, 50)}${card.text.length > 50 ? '...' : ''}"</p>
          <div class="flex justify-end space-x-3">
            <button id="confirmNo" class="px-4 py-2 text-gray-600 hover:text-gray-800">Cancel</button>
            <button id="confirmYes" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Delete</button>
          </div>
        </div>
      `;
      document.body.appendChild(confirmEl);

      return new Promise((resolve) => {
        document.getElementById('confirmNo').onclick = () => {
          document.body.removeChild(confirmEl);
          resolve(false);
        };
        document.getElementById('confirmYes').onclick = () => {
          document.body.removeChild(confirmEl);
          resolve(true);
        };
      });
    }

    // ================================
    // UI UPDATES
    // ================================

    /**
     * Re-render a single column
     * @param {string} columnId - ID of column to re-render
     */
    function reRenderColumn(columnId) {
      const columnEl = document.querySelector(`.kanban-column[data-column="${columnId}"]`);
      if (!columnEl) return;

      // Update card count
      const countEl = columnEl.querySelector('span:last-child');
      if (countEl) {
        countEl.textContent = boardState[columnId].length;
      }

      // Re-render cards container
      const cardsContainer = columnEl.querySelector(`[data-column="${columnId}"]`);
      if (cardsContainer) {
        cardsContainer.innerHTML = '';
        boardState[columnId].forEach(card => {
          const cardEl = createCardElement(card, columnId);
          cardsContainer.appendChild(cardEl);
        });
        // Re-setup drop zone
        setupDropZone(cardsContainer, columnId);
      }
    }

    // ================================
    // ANIMATIONS
    // ================================

    /**
     * Trigger confetti animation
     */
    function triggerConfetti() {
      const duration = 3 * 1000;
      const animationEnd = Date.now() + duration;
      const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 1000 };

      function randomInRange(min, max) {
        return Math.random() * (max - min) + min;
      }

      const interval = setInterval(() => {
        const timeLeft = animationEnd - Date.now();

        if (timeLeft <= 0) {
          return clearInterval(interval);
        }

        const particleCount = 50 * (timeLeft / duration);
        confetti(Object.assign({}, defaults, {
          particleCount,
          origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 }
        }));
        confetti(Object.assign({}, defaults, {
          particleCount,
          origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 }
        }));
      }, 250);
    }

    // ================================
    // EVENT DELEGATION FOR MODAL
    // ================================

    // Close modal when clicking outside
    modalEl.addEventListener('click', (e) => {
      if (e.target === modalEl) {
        closeModal();
      }
    });

    // Handle Enter key in textarea (but allow Shift+Enter for new line)
    cardContentEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        saveCard();
      }
    });
  </script>
</body>
</html>
```